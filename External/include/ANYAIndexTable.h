/*
This code was developed by Tansel Uras (turas@usc.edu) at USC.
The code is hosted at 'http://idm-lab.org/anyangle'.
If you use this code in your research, please  cite our SoCS paper:

T. Uras and S. Koenig,  2015. An Empirical Comparison of Any-Angle Path-Planning Algorithms. In: Proceedings of the 8th Annual Symposium on Combinatorial
Search. Code available at: http://idm-lab.org/anyangle

Bibtex:
@inproceedings{uras:15,
  author = "T. Uras and S. Koenig",
  title = "An Empirical Comparison of Any-Angle Path-Planning Algorithms",
  booktitle = {Proceedings of the 8th Annual Symposium on Combinatorial Search},
  year = "2015",
  note = "Code available at: http://idm-lab.org/anyangle",
}
*/

#ifndef ANYA_INDEX_TABLE_H
#define ANYA_INDEX_TABLE_H

#ifdef _WIN32
//#include <hash_map>
#include <unordered_map>
#else
#include <ext/hash_map>
#endif
#include "stdint.h"
#include <iostream>

#ifdef _WIN32
#include <float.h>
#define INFINITE_COST DBL_MAX
#define ANYA_KEY_NOT_FOUND ULLONG_MAX
#else
#define INFINITE_COST std::numeric_limits<cost>::max()
#define ANYA_KEY_NOT_FOUND std::numeric_limits<uint64_t>::max()
#endif

// Assumes that the map coordinates are smaller than 4096 (after padding). If this assumption holds, then the hash key generated by concatenating the last 12
// bits of root's x and y locations, interval's row. and interval's integer end-points (for a total of 60 bits) is unique for the given integer values.
// This way, ANYAState's memory footprint is small. This can be adapted to a more general case by having ANYAState store the five integer values mentioned above.

struct ANYAStateKey {
    ANYAStateKey (const uint64_t h, const double d_left, const double d_right)
    : hash(h), left(d_left), right(d_right)
    {}

    uint64_t hash;   // A hash of root's x and y locations, the row of the interval and the integer end-points of the interval.
    double left, right; // Actual end-points of the interval.
};

struct ANYAStateHash {
    size_t operator()(const ANYAStateKey &x) const {
        return (size_t) x.hash;
    }
};

struct ANYAStateEq {
    bool operator()(const ANYAStateKey &s1, const ANYAStateKey &s2) const {
        return  (s1.hash == s2.hash) &&
                (fabs(s1.left - s2.left) < EPSILON) &&
                (fabs(s1.right - s2.right) < EPSILON);
    }
};

class ANYAIndexTable{
public:
    ANYAIndexTable(){}
	~ANYAIndexTable(){}

	void Add(ANYAStateKey key, uint64_t value){
	    anya_state_table_[key] = value;
	}

	uint64_t Get(ANYAStateKey key){
#ifdef _WIN32
		std::unordered_map<ANYAStateKey, uint64_t, ANYAStateHash, ANYAStateEq>::const_iterator it;
#else
	    __gnu_cxx::hash_map<ANYAStateKey, uint64_t, ANYAStateHash, ANYAStateEq>::const_iterator it;
#endif
		it = anya_state_table_.find(key);
		if (it == anya_state_table_.end())
			return ANYA_KEY_NOT_FOUND;
		return (*it).second;
	}

	void Reset(){
	    anya_state_table_.clear();
	}

private:
#ifdef _WIN32
	std::unordered_map<ANYAStateKey, uint64_t, ANYAStateHash, ANYAStateEq> anya_state_table_;
#else
	__gnu_cxx::hash_map<ANYAStateKey, uint64_t, ANYAStateHash, ANYAStateEq> anya_state_table_;
#endif
};

#endif
